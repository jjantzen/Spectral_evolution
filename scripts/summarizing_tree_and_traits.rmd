---
title: "Tree and trait coverage"
author: "Johanna Jantzen"
date: "January 11, 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First load libraries.

```{r libraries, echo = FALSE}

library(spectrolab)
library(tidyr)
library(dplyr)
library(lubridate)
library(reshape2)
library(ggplot2)
library(forcats)
library(taxize)
library(jsonlite)
library(purrr)
library(tibble)
library(stringr)
library(flora)
library(phytools)

```

## Reading objects

The spectral data was from Shan Kothari (Oct 21, 2020) who did the spectral processing and filtering. The spectra were cleaned to fix metadata errors via the **dataset_stats.rmd** file. 

```{r spectra, echo=FALSE}

spectra_obj <- readRDS("../data/tidy/trimmed_spectra_with_meta.rds")

reduced_spectra_obj <- spectra_obj[which(spectra_obj$meta$project != "2019-Pardo-MSc-UdeM" & spectra_obj$meta$project != "SWA-Warren" & spectra_obj$meta$project != "CABO-General"),]

unique(reduced_spectra_obj$meta$project)

reduced_spectra_obj

species_spectra <- na.omit(unique(as.character(reduced_spectra_obj$meta$species_names)))
str(reduced_spectra_obj)

```

The tree was generated using sample names from the dataset but included several projects that are now excluded. The tree will need to be trimmed to match the spectral data (and vice versa). 

```{r tree, echo=FALSE}

#tree_obj <- readRDS("../analysis/from_cluster/trees/beast_sampled_100_trees_v2.rds")

tree_obj <- readRDS("../data/for_analysis/beast_sampled_100_trees_final.rds")

species_tree <- tree_obj$STATE_241090000$tip.label

list_of_trees <- tree_obj

```

Match the species in the spectra and the trees. 

```{r match tree spectra, echo=FALSE}

#if using original species names
# species_spectra_sm <- c()
# for (i in 1:length(species_spectra)){
#   species_spectra_sm[i] <- remove.authors(species_spectra[i])
# }
# 

species_spectra <- gsub("_", " ", species_spectra)

species_tree <- gsub("_", " ", species_tree)

#species not in spectra
missing_spectra <- species_tree[-which(species_tree %in% species_spectra)]

#species not in tree
missing_tree <- species_spectra[-which(species_spectra %in% species_tree)]

#changes to be made

#replace in tree: 
#Acer saccharum subsp. nigrum with Acer nigrum
#drop from tree:
#Gustavia superba, Anacardium excelsum, Agonis flexuosa

#replace in spectra:
#Phragmites australis subsp. australis with Phragmites australis, Kalmia angustifolia var angustifolia with Kalmia angustifolia
#if using original names:
#Prunus pensylvanica f. with Prunus pensylvanica, Bromus sitchensis var. carinatus with Bromus sitchensis 
#remove from spectra dataset:
#Quercus, Picea rubens, Solidago altissima

#figure out where some came from: Picea rubens, Solidago altissima

#single sample from Picea rubens
spectra_obj$meta$project[which("Picea_rubens" %in% spectra_obj$meta$species_names)]

#single sample from Solidago altissima
spectra_obj[which("Solidago_altissima" %in% spectra_obj$meta$species_names),]

#

unique(spectra_obj$meta$species_names)

```

```{r trim and rename tree and spectra, echo=FALSE}


#species not in spectra
missing_spectra 
missing_tree
class(list_of_trees)

####Trees

#replace in tree: 
#Acer saccharum subsp. nigrum with Acer nigrum
#drop from tree:
#Gustavia superba, Anacardium excelsum, Agonis flexuosa, Bromus inermis, Typha latifolia?



#drop tips
new_trees <- lapply(list_of_trees,drop.tip,tip=c("Gustavia_superba", "Anacardium_excelsum", "Agonis_flexuosa", "Eriophorum_vaginatum_subsp._spissum", "Rubus_idaeus_subsp._strigosus"))

#rename taxa
rename.tips <- function(phy, old_names, new_names) {
   mpos <- match(old_names,phy$tip.label)
   phy$tip.label[mpos] <- new_names
   phy$tip.label <- gsub("_", " ", phy$tip.label)
   return(phy)
}

new_trees <- lapply(new_trees, rename.tips, old_names = "Acer_saccharum_subsp._nigrum", new_names = "Acer nigrum")
new_trees <- lapply(new_trees, rename.tips, old_names = "Eriophorum vaginatum subsp. vaginatum", new_names = "Eriophorum vaginatum")
#new_trees <- lapply(new_trees, rename.tips, old_names = "Rubus idaeus subsp. strigosus", new_names = "Rubus idaeus")
new_trees <- lapply(new_trees, rename.tips, old_names = "Alnus incana subsp. rugosa", new_names = "Alnus incana")

####Spectra
reduced_spectra_obj

new_spectra <- reduced_spectra_obj

new_spectra$meta$species_names <- as.character(new_spectra$meta$species_names)

new_spectra$meta$species_names <- gsub("_", " ", new_spectra$meta$species_names)

#if using original species names
# for (i in 1:nrow(new_spectra$meta)){
#   new_spectra$meta$species_short[i] <- remove.authors(as.character(new_spectra$meta$species[i]))
# }

#rename taxa
#new_spectra$meta$species_short[which(new_spectra$meta$species_short == "Prunus pensylvanica f.")] <- "Prunus pensylvanica"
new_spectra$meta$species_names[which(new_spectra$meta$species_names == "Phragmites australis subsp. australis")] <- "Phragmites australis"
new_spectra$meta$species_names[which(new_spectra$meta$species_names == "Kalmia angustifolia var. angustifolia")] <- "Kalmia angustifolia"
#new_spectra$meta$species_short[which(new_spectra$meta$species_short == "Bromus sitchensis var. carinatus")] <- "Bromus sitchensis"
new_spectra$meta$species_names[which(new_spectra$meta$species_names == "Eriophorum vaginatum subsp. spissum")] <- "Eriophorum vaginatum"
new_spectra$meta$species_names[which(new_spectra$meta$species_names == "Eriophorum vaginatum subsp. vaginatum")] <- "Eriophorum vaginatum"
new_spectra$meta$species_names[which(new_spectra$meta$species_names == "Rubus idaeus subsp. strigosus")] <- "Rubus idaeus"
new_spectra$meta$species_names[which(new_spectra$meta$species_names == "Alnus incana subsp. rugosa")] <- "Alnus incana"


#replace in spectra:
#Prunus pensylvanica f. with Prunus pensylvanica, Phragmites australis subsp. australis with Phragmites australis, Kalmia angustifolia var angustifolia with Kalmia angustifolia, Bromus sitchensis var. carinatus with Bromus sitchensis

#drop from spectra dataset
new_spectra <- new_spectra[-which(new_spectra$meta$species_names == "Quercus" | new_spectra$meta$species_names == "Picea rubens" | new_spectra$meta$species_names == "Solidago altissima")]

#remove from spectra dataset:
#Quercus, Picea rubens, Solidago altissima


#rename for both to reduce subspecies 
# Eriophorum_vaginatum_subsp. spissum
# Eriophorum_vaginatum_subsp. vaginatum
# Rubus_idaeus_subsp. strigosus
# Alnus_incana_subsp. rugosa


```

Check to see if they match now.

```{r check tree spectra, echo=FALSE}


species_tree_2 <- new_trees$STATE_241090000$tip.label

species_spectra_2 <- unique(as.character(new_spectra$meta$species_names))

#species not in spectra
missing_spectra2 <- species_tree_2[-which(species_tree_2 %in% species_spectra_2)]

#species not in tree
missing_tree2 <- species_spectra_2[-which(species_spectra_2 %in% species_tree_2)]

unique(new_spectra$meta$species_names)

# #figure out which samples have NA as species - resolved by using species_names not species
# unique(new_spectra$meta$project[which(is.na(new_spectra$meta$species_names))])
# unique(reduced_spectra_obj$meta$project[which(is.na(reduced_spectra_obj$meta$species))])
# 
# reduced_spectra_obj$meta$species[which(reduced_spectra_obj$meta$project == "2019-Phragmites-temporal")]

```

Save these matched datasets.
```{r save rds, echo=FALSE}

#saveRDS(new_spectra, "../data/tidy/new_spectra_matched_trees.rds")
saveRDS(new_spectra, "../data/for_analysis/final_spectra_matched_trees.rds")

# saveRDS(new_trees, "../data/tidy/new_trees_matched_spectra.rds")
saveRDS(new_trees, "../data/for_analysis/final_trees_matched_spectra.rds")

new_trees[[1]]$tip.label

```

See if we have trait data for these taxa. 
```{r compare with trait data, echo=FALSE}

trait_data_try <- readRDS("../data/predictors/try_trait_data_cleaned.rds")

colnames(trait_data_try)

#trait_data_try$Species

growth_form_data <- readRDS("../data/tidy/growth_form_tidy.rds")

colnames(growth_form_data)

#change species names to match format
growth_form_data_namefixed <- growth_form_data
for (i in 1:nrow(growth_form_data)){
  growth_form_data_namefixed$species_names[i] <- remove.authors(growth_form_data$scientific_name[i])
}

unique(growth_form_data_namefixed$species_names)

#names to fix
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Bromus sitchensis var. carinatus")] <- "Bromus sitchensis"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Alnus incana subsp. rugosa")] <- "Alnus incana"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Eriophorum vaginatum subsp. vaginatum")] <- "Eriophorum vaginatum"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Eriophorum vaginatum subsp. spissum")] <- "Eriophorum vaginatum"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Kalmia angustifolia var. angustifolia")] <- "Kalmia angustifolia"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Phragmites australis subsp. australis")] <- "Phragmites australis"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Rubus idaeus subsp. strigosus")] <- "Rubus idaeus"
growth_form_data_namefixed$species_names[which(growth_form_data_namefixed$species_names == "Solidago altissima var. altissima")] <- "Solidago altissima"

#get rid of duplicates

dups <- growth_form_data_namefixed[which(duplicated(growth_form_data_namefixed$species_names) == TRUE),]
dups$species_names

growth_form_data_namefixed[which(growth_form_data_namefixed$species_names %in% dups$species_names),]

growth_form_data_2 <- growth_form_data_namefixed[-which(duplicated(growth_form_data_namefixed$species_names) == TRUE),]

#rearrange columns
growth_form_data_2 <- growth_form_data_2[,c(1,8,2:7)]

#fixing mismatches from below

growth_form_data_2$species_names[which(growth_form_data_2$species_names == "Prunus pensylvanica f.")] <- "Prunus pensylvanica"

#match trait taxa with spectra taxa
spec_names <- unique(new_spectra$meta$species_names)
gf_names <- growth_form_data_2$species_names
try_names <- trait_data_try$Species

#was just Prunus pensylvanica f.
#otherwise all spec data in gf data
spec_names[which(spec_names %in% gf_names == FALSE)]

#several missing from try data
spec_names[which(spec_names %in% try_names == FALSE)]

####These aren't as important (just mismatch in datasets in coverage)
#all try data are in gf data
try_names[which(try_names %in% gf_names == FALSE)]

#we have trait data for Picea rubens but not in tree/spectra
try_names[which(try_names %in% spec_names == FALSE)] #we'll drop these from try data

#we have gf data for 18 taxa not in spectra anymore
gf_names[which(gf_names %in% spec_names == FALSE)] #we'll drop these from gf data

#we have gf data for 28 taxa not in trait data
gf_names[which(gf_names %in% try_names == FALSE)]

#drop trait data for which no spectra/tree

#drop Picea rubens from try data
new_try <- trait_data_try[-which(trait_data_try$Species == try_names[which(try_names %in% spec_names == FALSE)]),]

#drop 18 taxa from gf data
new_gf <- growth_form_data_2[-which(growth_form_data_2$species_names %in% gf_names[which(gf_names %in% spec_names == FALSE)]),]



```

We have matching taxa for the growth form data, tree, and spectra. We have 89 of 100 taxa in the try dataframe. 

```{r save rds 2, echo=FALSE}

saveRDS(new_gf, "../data/tidy/new_growth_forms_matched_spectra.rds")

saveRDS(new_try, "../data/tidy/new_try_data_matched_spectra.rds")

```

Get stats on family and taxonomy representation in the end. 
```{r get taxonomy, echo=FALSE}

taxonomy <- readRDS("../data/predictors/vascan_taxonomy.rds")

colnames(taxonomy)[1] <- "Species"
taxonomy$Species <- as.character(taxonomy$Species)

spec_names[which(spec_names %in% taxonomy$Species == FALSE)]
taxonomy$Species[which(taxonomy$Species %in% spec_names == FALSE)]

str(taxonomy)

#need to add a few entries to taxonomy table and fix synonym for Berberis in taxonomy table
str(taxonomy)

#get taxonomy for missing taxa
fern <- c("Polystichum munitum", "Equisetopsida", "Polypodiidae", NA, "Polypodiales", "Dryopteridaceae", "Dryopteridoideae", NA, NA)
bromus <- c("Bromus inermis", "Equisetopsida", "Magnoliidae", "Lilianae", "Poales", "Poaceae", "Pooideae", "Bromeae", NA)
typha <- c("Typha latifolia", "Equisetopsida", "Magnoliidae", "Lilianae", "Poales", "Typhaceae", NA, NA, NA)

#add to dataframe
taxonomy_2 <- rbind(taxonomy, fern, bromus, typha)

#drop Pinus rubens
taxonomy_2 <- taxonomy_2[-which(taxonomy_2$Species == "Picea rubens"),]

#rename Mahonia aquifolium to Berberis aquifolium
taxonomy_2$Species[which(taxonomy_2$Species == "Mahonia aquifolium")] <- "Berberis aquifolium" 

new_tax <- taxonomy_2

```

Save output taxonomy.
```{r save file, echo=FALSE}

saveRDS(new_tax, "../data/tidy/new_taxonomy_matched_spectra.rds")

```


Soil data matching. 

```{r compare with trait data 2, echo=FALSE}

trait_data_try <- readRDS("../data/predictors/spread_try_data_soil.rds")

new_spectra <- readRDS("../data/tidy/new_spectra_matched_trees.rds")

colnames(trait_data_try)[1] <- "Species"

#match trait taxa with spectra taxa
spec_names <- unique(new_spectra$meta$species_names)

try_names <- trait_data_try$Species

unique(try_names)

#several missing from try data
spec_names[which(spec_names %in% try_names == FALSE)]

#we have trait data for Picea rubens but not in tree/spectra
try_names[which(try_names %in% spec_names == FALSE)] #we'll drop these from try data

#drop Picea rubens from try data
new_try2 <- trait_data_try[-which(trait_data_try$Species %in% try_names[which(try_names %in% spec_names == FALSE)]),]


saveRDS(new_try2, "../data/tidy/new_try_soil_matched_spectra.rds")


```

Read in files for below if needed. 

```{r read files new, echo=FALSE}

new_gf <- readRDS("../data/tidy/new_growth_forms_matched_spectra.rds")

new_try <- readRDS("../data/tidy/new_try_data_matched_spectra.rds")

new_spectra <- readRDS("../data/tidy/new_spectra_matched_trees.rds")

new_trees <- readRDS("../data/tidy/new_trees_matched_spectra.rds")

new_tax <- readRDS("../data/tidy/new_taxonomy_matched_spectra.rds")

new_soil <- readRDS("../data/tidy/new_try_soil_matched_spectra.rds")


```

Calculate stas for coverage for each character

```{r calc stats, echo=TRUE, fig.keep = 'all'}

colnames(new_gf)[2] <- "Species"

combo_data <- merge(new_gf, new_try, by = "Species", all.x = TRUE)

combo_data <- merge(combo_data, new_tax, by = "Species")

combo_data <- merge(combo_data, new_soil, by = "Species", all.x = TRUE)

colnames(combo_data)

#calculate proportion of NA vs value
#don't need to turn into percent because 100 taxa
missing_props <- combo_data %>% 
  select(-(contains("Reference")|contains("Comment"))) %>% 
  summarise_all(funs(sum(is.na(.))))

colnames(combo_data)

reduced_combo <- combo_data[,c(1:19,29:42)]

str(combo_data)

write.csv(reduced_combo, "../data/tidy/new_combo_data_matched_spectra.csv")

write.csv(missing_props, "../data/tidy/proportions_missing_data_traits.csv")

saveRDS(combo_data, "../data/tidy/new_combo_data_matched_spectra.rds")

```

Calculate mean spectra per species and save as object for correlation tests.
```{r mean spectra, echo=FALSE}

spectra_df <- as.data.frame(new_spectra, row.names = new_spectra$meta$species_names, metadata = TRUE)#, colnames = bands)

colnames(spectra_df)[1:200]
ncol(spectra_df)

#get mean of spectra
spectra_means <- spectra_df[,c(29,166:2166)] %>% 
  #dplyr::select(-c(sample_name)) %>% 
  group_by(species_names) %>% 
  summarize_all(mean, na.rm = TRUE)

#3 format data
spectra_means_df <- data.frame(spectra_means, stringsAsFactors = FALSE)

row.names(spectra_means_df) <- as.character(spectra_means_df$species_names)
spectra_means_df <- spectra_means_df[,-1]
colnames(spectra_means_df) <- gsub("X", "", colnames(spectra_means_df))

spec_list <- as.matrix(spectra_means_df)

#reorder spectra to match tree?
reorder_spec <- match(dimnames(spec_list)[[1]], new_trees[[1]]$tip.label)
reordered_spec <- as.matrix(spectra_means_df[reorder_spec])

#combine data into one dataframe
data_spectra <- list(trait=reordered_spec, predictor=as.factor(new_gf$Woody)) #matrix(spectra_means_df)

saveRDS(reordered_spec, "../data/tidy/spectra_reordered_to_tree.rds")
saveRDS(data_spectra, "../data/tidy/spectra_means_matched_to_tree.rds")

saveRDS(spec_list, "../data/tidy/spectra_not_reordered_to_tree.rds")
spec_list

```
Conduct correlation tests to assess for collinearity of traits. Test for influential cases. 

```{r collinearity and influential cases, echo=TRUE, fig.keep = 'all'}

library("MASS")
library("rcompanion")
library("lsr")
library("vcd")
library("DescTools")


combo_data <- readRDS("../data/tidy/new_combo_data_matched_spectra.rds")
lineage_reordered <- saveRDS("../data/tidy/spectra_reordered_to_tree.rds")

#add all relevant trait data to spectra
data_spectra <- list(trait=lineage_reordered, woody=as.factor(combo_data$Woody), ShadeTol = as.factor(combo_data$ShadeTolerance_Qual), DroughtTol = as.factor(combo_data$DroughtTolerance_Qual), Myc_NM = as.factor(combo_data$Myc_NM), subclass = as.factor(combo_data$Subclass))

#didn't work
# #run model
# #model <- lm(trait ~ woody + ShadeTol , data = data_spectra) #+ DroughtTol + Myc_NM + subclass
# summary(model)
# 
# #ols_vif_tol(model)

#contingency table
table(combo_data$Woody, combo_data$Tree)
table(combo_data$Woody, combo_data$Myc_NM)
table(combo_data$Woody, combo_data$ShadeTolerance_Qual)
table(combo_data$Woody, combo_data$DroughtTolerance_Qual)
table(combo_data$Woody, combo_data$Subclass)
table(combo_data$ShadeTolerance_Qual, combo_data$Myc_AM)
table(combo_data$ShadeTolerance_Qual, combo_data$Myc_EM)
table(combo_data$DroughtTolerance_Qual, combo_data$Myc_EM)
table(combo_data$DroughtTolerance_Qual, combo_data$Myc_AM)

table(combo_data$DroughtTolerance_Quant, combo_data$Woody)
table(combo_data$ShadeTolerance_Quant, combo_data$Woody)


table(combo_data$coarse_soil, combo_data$Woody)
table(combo_data$fine_soil, combo_data$Woody)
table(combo_data$medium_soil, combo_data$Woody)



#chi squared test
chisq.test(combo_data$Woody, combo_data$Tree) #significant
chisq.test(combo_data$Woody, combo_data$Myc_NM)
chisq.test(combo_data$Woody, combo_data$ShadeTolerance_Qual)
chisq.test(combo_data$Woody, combo_data$DroughtTolerance_Qual)
chisq.test(combo_data$Woody, combo_data$Subclass) #significant
chisq.test(combo_data$ShadeTolerance_Qual, combo_data$Myc_AM)
chisq.test(combo_data$ShadeTolerance_Qual, combo_data$Myc_EM)
chisq.test(combo_data$DroughtTolerance_Qual, combo_data$Myc_EM)
chisq.test(combo_data$DroughtTolerance_Qual, combo_data$Myc_AM)
chisq.test(combo_data$DroughtTolerance_Qual, combo_data$Myc_NM)
chisq.test(combo_data$ShadeTolerance_Qual, combo_data$Myc_NM)

chisq.test(combo_data$coarse_soil, combo_data$Woody) #significant
chisq.test(combo_data$fine_soil, combo_data$Woody)
chisq.test(combo_data$medium_soil, combo_data$Woody) 

chisq.test(combo_data$medium_soil, combo_data$Myc_NM)
chisq.test(combo_data$fine_soil, combo_data$Myc_NM) 
chisq.test(combo_data$coarse_soil, combo_data$Myc_NM)

chisq.test(combo_data$coarse_soil, combo_data$Myc_EM)
chisq.test(combo_data$fine_soil, combo_data$Myc_EM)
chisq.test(combo_data$medium_soil, combo_data$Myc_EM)

chisq.test(combo_data$coarse_soil, combo_data$DroughtTolerance_Qual)
chisq.test(combo_data$fine_soil, combo_data$DroughtTolerance_Qual)
chisq.test(combo_data$medium_soil, combo_data$DroughtTolerance_Qual)

chisq.test(combo_data$coarse_soil, combo_data$Subclass)
chisq.test(combo_data$fine_soil, combo_data$Subclass) #marginal, almost sig
chisq.test(combo_data$medium_soil, combo_data$Subclass)

#for missing data and other variables

colnames(combo_data)


shade_categories <- combo_data[,c(1,8,9)]
shade_categories$ShadeTolerance_Quant[which(!is.na(shade_categories$ShadeTolerance_Quant))] <- "yes"
shade_categories$ShadeTolerance_Quant[which(is.na(shade_categories$ShadeTolerance_Quant))] <- "no"

drought_categories <- combo_data[,c(1,8,11)]
drought_categories$DroughtTolerance_Quant[which(!is.na(drought_categories$DroughtTolerance_Quant))] <- "yes"
drought_categories$DroughtTolerance_Quant[which(is.na(drought_categories$DroughtTolerance_Quant))] <- "no"

chisq.test(shade_categories$ShadeTolerance_Quant, shade_categories$Woody) #significant (missing/not for woody)
chisq.test(drought_categories$DroughtTolerance_Quant, drought_categories$Woody) #significant (missing/not for woody)


myc_categories <- combo_data[,c(1,8,18)]
myc_categories$Myc_NM[which(!is.na(myc_categories$Myc_NM))] <- "yes"
myc_categories$Myc_NM[which(is.na(myc_categories$Myc_NM))] <- "no"

chisq.test(myc_categories$Myc_NM, myc_categories$Woody) #not significant (missing/not for woody)

myc_categories2 <- combo_data[,c(1,10,18)]
myc_categories2$Myc_NM[which(!is.na(myc_categories2$Myc_NM))] <- "yes"
myc_categories2$Myc_NM[which(is.na(myc_categories2$Myc_NM))] <- "no"

chisq.test(myc_categories2$Myc_NM, myc_categories2$ShadeTolerance_Qual) #not significant (missing/not for shade tolerance)



shade_qual_categoriers <- combo_data[,c(1,8,10)]
shade_qual_categoriers$ShadeTolerance_Qual[which(!is.na(shade_qual_categoriers$ShadeTolerance_Qual))] <- "yes"
shade_qual_categoriers$ShadeTolerance_Qual[which(is.na(shade_qual_categoriers$ShadeTolerance_Qual))] <- "no"

chisq.test(shade_qual_categoriers$ShadeTolerance_Qual, shade_qual_categoriers$Woody) #significant

drought_qual_categoriers <- combo_data[,c(1,8,12)]
drought_qual_categoriers$DroughtTolerance_Qual[which(!is.na(drought_qual_categoriers$DroughtTolerance_Qual))] <- "yes"
drought_qual_categoriers$DroughtTolerance_Qual[which(is.na(drought_qual_categoriers$DroughtTolerance_Qual))] <- "no"

chisq.test(drought_qual_categoriers$DroughtTolerance_Qual, drought_qual_categoriers$Woody) #significant relationship between missing data and woodiness

colnames(combo_data)

soil_coarse_cat <- combo_data[,c(1,8,38)]
soil_coarse_cat$coarse_soil[which(!is.na(soil_coarse_cat$coarse_soil))] <- "Yes"
soil_coarse_cat$coarse_soil[which(is.na(soil_coarse_cat$coarse_soil))] <- "No"

chisq.test(soil_coarse_cat$coarse_soil, soil_coarse_cat$Woody) #significant relationship between missing data and woodiness


soil_fine_cat <- combo_data[,c(1,8,39)]
soil_fine_cat$fine_soil[which(!is.na(soil_fine_cat$fine_soil))] <- "Yes"
soil_fine_cat$fine_soil[which(is.na(soil_fine_cat$fine_soil))] <- "No"

chisq.test(soil_fine_cat$fine_soil, soil_fine_cat$Woody) #significant relationship between missing data and woodiness


soil_med_cat <- combo_data[,c(1,8,40)]
soil_med_cat$medium_soil[which(!is.na(soil_med_cat$medium_soil))] <- "Yes"
soil_med_cat$medium_soil[which(is.na(soil_med_cat$medium_soil))] <- "No"

chisq.test(soil_med_cat$medium_soil, soil_med_cat$Woody) #significant relationship between missing data and woodiness


#pairs

#getting taxonomy info
length(levels(as.factor(combo_data$Family)))

n_per_family <- combo_data %>% 
  group_by(Family) %>% 
  summarize(n = n())%>% 
  arrange(desc(n))


n_per_species <- spectra_df %>% 
  dplyr::select(-c(sample_name)) %>% 
  group_by(species_names) %>% 
  summarize(n = n()) %>% 
  arrange(desc(n))

```


Get references for TRY data. 
```{r try refs}

unique(new_try$ReferenceShade_Qual)
unique(new_try$ReferenceShade_Quant)

unique(new_try$ReferenceDrought_Qual)
unique(new_try$ReferenceDrought_Quant)

#would there be bias in the distribution of missing data if using the quant?
new_try$Species[which(is.na(new_try$ReferenceShade_Qual))]

unique(new_try$ReferenceMycBinaries)

#if no reference, no data for myc
new_try$Myc_ErM[which(is.na(new_try$ReferenceMycBinaries))]

#interpretation of non-mycorrhizal (could be false negative if few observations)


unique(new_try$DroughtTolerance_Qual)
unique(new_try$ShadeTolerance_Qual)
unique(new_try$Myc_AM)

length(unique(new_try$Species[which(!is.na(new_try$ShadeTolerance_Qual))]))
length(unique(new_try$Species[which(!is.na(new_try$DroughtTolerance_Qual))]))


```

``` {r for final analysis dataframes}

spec_list <- readRDS("../data/tidy/spectra_not_reordered_to_tree.rds")

#dataframe we want: combo_data
combo_data <- readRDS("../data/tidy/new_combo_data_matched_spectra.rds")

# new_gf
# new_soil
# new_spectra
# new_tax
# new_trees
# new_try

str(spec_list) #only spectra - means
str(new_spectra) #has all the metadata and individual samples

#read in gaps filled in dataframe and official TOPIC database
filled_db <- read.csv("../data/predictors/filling_in_gaps_2.csv", stringsAsFactors = FALSE)
filled_db

topic_db <- read.csv("../data/TOPIC/TOPIC_JJantzen_Filled.csv", stringsAsFactors = FALSE)
topic_db

gaps_db <- read.csv("../data/predictors/shade_gaps_data.csv", stringsAsFactors = FALSE)
gaps_db

#compare with combo data
sum(is.na(combo_data$`Adapted to Coarse Textured Soils`))
sum(is.na(filled_db$Adapted.to.Coarse.Textured.Soils))

sum(is.na(combo_data$ShadeTolerance_Qual))
sum(is.na(filled_db$ShadeTolerance_Qual))

sum(is.na(combo_data$DroughtTolerance_Qual))
sum(is.na(filled_db$DroughtTolerance_Qual))

#filled in some of the missing data so keep from filled_db not combo_data

#but keep  Raunk and lp from topic not filled_db

#assemble final database??
colnames(combo_data)

#keep taxonomy, gf from combo_data
final_data <- combo_data[,c(1,3:5,8,31:34)]

#add soil, drought and shade data from filled_db
colnames(filled_db)
final_data <- cbind(final_data, filled_db[,c(1,8,12,23:27)])

#add lp, rk lf and habitat from TOPIC
colnames(topic_db)

#slight mismatch in species lists - fixed in csv file
final_data$Species[which(final_data$Species %in% topic_db$Species == FALSE)]
topic_db$Species[which(topic_db$Species %in% final_data$Species == FALSE)]

final_data <- cbind(final_data, topic_db[,c(1,3:5)])

colnames(final_data)

#first check if they're identical
identical(final_data[[1]],final_data[[18]])

#get rid of extra species columns
final_data <- final_data[,-c(10, 18)]

#check out final data
final_data

#get more general Rk lf column
final_data$Raunk.general <- final_data$Raunkiaer.Life.Form
final_data$Raunk.general[which(final_data$Raunk.general == "mg")] <- "p"
final_data$Raunk.general[which(final_data$Raunk.general == "mc")] <- "p"
final_data$Raunk.general[which(final_data$Raunk.general == "mc (mg)")] <- "p"
final_data$Raunk.general[which(final_data$Raunk.general == "mc / mg")] <- "p"
final_data$Raunk.general[which(final_data$Raunk.general == "mg (mc)")] <- "p"
final_data$Raunk.general <- gsub("mc", "p", final_data$Raunk.general)
final_data$Raunk.general <- gsub("mg", "p", final_data$Raunk.general)
final_data$Raunk.general <- gsub("g", "c", final_data$Raunk.general)
final_data$Raunk.general <- gsub("hel", "p", final_data$Raunk.general)
final_data$Raunk.general <- gsub("hyd", "p", final_data$Raunk.general)
final_data$Raunk.general <- gsub("(", "+ ", final_data$Raunk.general, fixed = TRUE)
final_data$Raunk.general <- gsub("/", "+", final_data$Raunk.general, fixed = TRUE)
final_data$Raunk.general <- gsub(")", "", final_data$Raunk.general, fixed = TRUE)

unique(final_data$Raunk.general)

#get summary pH column
final_data$pH..Maximum <- as.numeric(final_data$pH..Maximum)
final_data$pH..Minimum <- as.numeric(final_data$pH..Minimum)

min(final_data$pH..Maximum, na.rm = TRUE) #4 to 9
max(final_data$pH..Maximum, na.rm = TRUE) #4 to 9

min(final_data$pH..Minimum, na.rm = TRUE) #2.98 to 6.5
max(final_data$pH..Minimum, na.rm = TRUE) #2.98 to 6.5

colnames(final_data)

final_data[,c(15:16)]

#plot distribution of ph values
library(ggplot2)

ggplot(data = final_data)+
  geom_histogram(aes(pH..Maximum), fill = "red")+
  geom_histogram(aes(pH..Minimum), fill = "blue")

#how to bin pH values? or keep them as quantitative?
final_data

#write final dataset to file for plotting - maybe revisit if changing ph column at all
saveRDS(final_data, "../data/for_analysis/final_data.rds")

```